

每个arena从一个或多个堆上获取可分配的内存。main arena使用进程空间初始的堆，其它的arena调用mmap分配堆内存。

堆中的chunk要么被分配给了应用，要么是空闲待分配。待分配的chunk按照大小和最近使用存放在各种有序链表中，便于在需要分配时快速找到合适的chunk，这些存放chunk的链表称为bin。

>内存延迟分配，用户态程序使用malloc分配内存时，是分的虚拟内存，只有真正访问内存时，才建立虚拟内存到物理内存的映射。
>求证一下这一点

动态内存分配器的设计与实现是计算机系统中很经典的问题，《深入理解计算机系统》中有详细的论述。ptmalloc是glibc中实现的一种动态内存分配器，结合通用动态存储分配器的设计原则，分析ptmalloc的设计与实现原理。

##### 为什么需要动态存储分配器
因为很多时候程序在运行过程中才知道需要分配多大的内存空间，通过硬编码的方式指定数据所需的内存空间很不灵活，可能浪费空间，也可能需要不时的修改代码来调整指定的空间大小。

##### 内存碎片

内存碎片分为内部碎片和外部碎片。内部碎片是指已分配块的大小比用户请求的大。分配器最小可分配的块比用户请求的块小，或者满足对齐要求都可能产生内部碎片。外部碎片是指多个非连续的空闲块大小加在一起可满足用户请求，但没有一个单独的空闲块满足，这些空闲块就成为外部碎片。

##### 如何设计动态存储分配器
动态存储分配器的设计目标有两个：
一是分配请求的吞吐率最大化，比如一分钟内能最多满足多少个分配与释放请求尽量多，合理的吞吐性能是指完成分配请求的最长时间与空闲块数量成线性关系。
另一个是提高存储空间有效利用率，虽然虚拟地址空间足够大，但系统可供所有进程动态分配的虚拟内存是有限的，它受限于磁盘交换空间的大小。而影响内存利用率的主要原因是内存碎片，因此，尽量少的内存碎片，分配给用户的有效内存空间尽量的多。
这两个目标是相悖的，一个分配器的实现只能在两者间找到一个合适的平衡点。实现过程中如何找到合适的平衡呢？通常从这几个方面去考虑：
* 如何组织空闲块
* 如何选择一个合适的空闲块来放置一个新分配的块
* 一个新分配块放置到空闲块中后，如何处理空闲块中剩余的部分
* 如何处理释放的块

任何分配器的实现都需要一些数据结构，来指明块大小，区分块的边界，区别已分配的块和空闲的块，这些数据称为元数据，大多数分配器的实现将这些元数据嵌入块本身，元数据在块中的组织方式形成了块的格式。元数据和系统对内存对齐的要求，导致分配器必须指定最小块的大小。

此处放置堆块格式图

放置已分配块

当一个应用请求x字节的块时，分配器如何从空闲块中找到合适的空闲块来满足请求？最容易想到的是首次适配和最佳适配两种策略，前者是找到一个大小x字节的块就返回，后者是遍历所有空闲块，找到大小最接近x字节的空闲块。两者的优劣在吞吐率和利用率上各占优势。

分割块

分配器找到一块空闲块后，立即面临另一个问题，是使用整个空闲块呢，还是只用其中一部分。前者很简单，但容易产生内部碎片；后者实现复杂，可减少内部碎片。两者仍然是在吞吐轨和利用率上各执一端。

扩展堆内存

如果在堆内存中找不到合适的空闲块来满足内存分配请求，分配器该怎么办呢？一种可能是合并物理上连续的空闲内存块，如果还是不能满足，只能向内核申请内存来扩展堆内存。

合并空闲块

当应用释放一块内存时，这块内存可能和另外一块空闲块在物理上是连续，分配器必须实现这种相邻空闲块的合并，以满足后续分配请求。合并是在应用释放时立即执行吗，还是推迟合并，等到有更多可合并的空闲块再执行，通常后者效率更高。

当前释放的块与位于它后面的相邻空闲块合并是简单的，当前释放块起始地址偏移块长度就可获取到下一块的元数据，如果可合并，更新块size就可以了。如果相邻空闲块在当前释放块的后面(位于低地址)，合并过程是怎样的呢？在遍历堆块时，需要记住已遍历的块地址，直到遇到当前要释放的块。有一种更简单优雅的合并方法叫做边界标记，在每个块的尾部放置一个块头部的副本作为块的边界信息，分配器就知道前面的相邻块是否空闲，从而快速决定能否合并，进一步归纳总结，发现只需要空闲块在尾部放置这个边界信息。

如何组织空闲块

在块元数据中加入链表指针，将所有空闲块通过链表维护起来。链表中的空闲块可按照某种策略进行排序，比如，可按照块地址升序排列，释放的块需要搜索链表找到正确的插入点，还可以将最新释放的块直接插入链表头部。两者对吞吐率和利用率上也是各执一端。

地址升序排列的空闲块链表，有较好的内存利用率，但搜索空闲块会影响吞吐率，且耗时随着空闲块数量线性增长。一种改进方法是将链表拆分成多个链表，从而提高搜索效率，这种方法称为分离存储。

### ptmalloc
Glibc中实现的动态内存分配器称为ptmalloc(pthreads malloc)。 malloc和free是用户态应用程序常用的分配与释放内存接口。

ptmalloc有两种分配内存的方式 ，一种是从堆上分配小块内存，另一种是调用mmap分配一段匿名映射的大块内存。使用哪种方式取决于分配的大小和用户传的的分配控制参数，也可以关闭mmap这种分配方式。动态内存分配器主要管理堆内存分配，通过mmap方式分配内存不会产生内存碎片，因为一旦释放就立即返还给了操作系统。
##### Arena
创建进程时，地址空间中会初始化一个堆内存区，但ptmalloc会建立并维护多个这样的堆内存区，每个堆内存区被称为arena，多个arena的目的是优化多线程应用的内存分配性能。进程地址空间最初的堆内存区称为main arena，其它的堆内存区通过mmap分配。堆内存区是ptmalloc从操作系统那批发的大块内存，然后再切成小块零售给应用程序，应用程序释放后又被回收，这不停地切割与回收，就会产生碎片，举个极端的例子，应用程序需要32K的连续内存，现在却只有8个非连续的空闲4K内存块。为了避免这种情况出现，回收时就要去合并整理空闲内存块。
##### Chunk
Glibc将堆分割成各种大小的chunk，chunk由头部和有效载荷payload组成，此外还可能有为了满足对齐要求的填充。

此处放chunk的结构图

头部中包含了元数据，已分配的chunk，元数据只有chunk的大小。空闲chunk还会在payload中放置arena相关的元数据，比如，双链表指针，分配内存时用来快速地选择合适的空闲块。

特别要说明的是，空闲chunk在payload最后一个字段放置的是chunk大小，这是一种称为边界标记(boundary tag)的技术实现，用来实现常数时间内合并当前chunk与它前面的空闲chunk。

chunk的地址被要求按8字节对齐，chunk的大小一定是8的倍数，这样，chunk大小的低3位就是0，存放size的字段低3位可用来编码三个标志位，这几个标志为用来指示chunk从哪里来，是空闲还是已分配。

* A(Allocated Arena) 该标志位为0，表示chunk是从main arena分配的，为1表示arena是mmap分配的arena分配的
* M(Mmap'd) 该标志置为1表示chunk是直接调用mmap分配的，不属于堆内存
* P(Prev in use) 该标志置为1，表示相邻的前一个chunk非空闲

```
struct mallock_chunk {
    INTERNAL_SIZE_T    mchunk_prev_size;
    INTERNAL_SIZE_T    mchunk_size;
    struct malloc_chunk *fd;
    struct malloc_chunk *bk;
    struct malloc_chunk *fd_nextsize;
    struct malloc_chunk *bk_nextsize;
}
```

##### 参考链接
1. [The GNU Allocator](https://www.gnu.org/software/libc/manual/html_node/The-GNU-Allocator.html)
2. [malloc实现原理](https://sourceware.org/glibc/wiki/MallocInternals)
3. [Glibc内存管理--ptmalloc2源代码分析](https://blog.csdn.net/iteye_7858/article/details/82045969)
4. 《深入理解计算机系统》